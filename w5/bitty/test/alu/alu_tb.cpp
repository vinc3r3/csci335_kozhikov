/*
#include <verilated.h>
#include "Valu.h"        // This is generated by Verilator based on alu.v
#include <cstdlib>       // For random number generation
#include <ctime>         // For seeding the random generator
#include <iostream>      // For printing outputs
#include <verilated_vcd_c.h>  // Optional for VCD (waveform) tracing

int main(int argc, char **argv) {
    // Initialize Verilated environment
    Verilated::commandArgs(argc, argv);

    // Instantiate ALU module
    Valu* top = new Valu;

    // Optional VCD tracing
    //VerilatedVcdC* tfp = new VerilatedVcdC;
    //Verilated::traceEverOn(true);
    //top->trace(tfp, 99);
    //tfp->open("alu_trace.vcd");

    // Seed the random number generator
    std::srand(static_cast<unsigned int>(std::time(0)));

    // Number of tests to run
    const int num_tests = 1;

    // Test logic for each mode (mode = 0 for Arithmetic, mode = 1 for Logic)
    for (int mode = 0; mode <= 1; ++mode) {
        std::cout << "Testing " << (mode ? "Logic" : "Arithmetic") << " Operations\n";
        for (int op = 0; op <= 15; ++op) {  // Loop through all 16 ALU operations (select from 0000 to 1111)
            std::cout << "  Operation select = " << op << "\n";
            for (int i = 0; i < num_tests; ++i) {
                // Random inputs
                top->in_a = std::rand() & 0xFFFF;  // 16-bit random input for in_a
                top->in_b = std::rand() & 0xFFFF;  // 16-bit random input for in_b
                top->carry_in = std::rand() & 0x1; // 1-bit random carry_in
                top->select = op;                  // Current operation select
                top->mode = mode;                  // Mode: 0 = Arithmetic, 1 = Logic

                // Evaluate the ALU
                top->eval();

                // Log the output
                std::cout << "Test " << i + 1 << ": in_a = " <<  top->in_a
                          << ", in_b = " << top->in_b
                          << ", carry_in = " << (int) top->carry_in
                          << ", alu_out = " <<  top->alu_out
                          << ", carry_out = " << (int) top->carry_out
                          << ", compare = " << (int) top->compare << "\n";

                // Optional: Dump waveform to VCD file
               // tfp->dump(i + (op * num_tests) + (mode * 16 * num_tests));
            }
        }
    }

    // Clean up
    top->final();
    //tfp->close();
    delete top;
    return 0;
}


*/



#include <verilated.h>
#include "Valu.h"        // This is generated by Verilator based on alu.v
#include <cstdlib>       // For random number generation
#include <ctime>         // For seeding the random generator
#include <iostream>      // For printing outputs
#include <cassert>       // For asserting correctness

int main(int argc, char **argv) {
    // Initialize Verilated environment
    Verilated::commandArgs(argc, argv);

    // Instantiate ALU module
    Valu* top = new Valu;

    // Seed the random number generator
    std::srand(static_cast<unsigned int>(std::time(0)));

    // Number of tests to run
    const int num_tests = 5;

    // Test logic for each mode (mode = 0 for Arithmetic, mode = 1 for Logic)
    for (int mode = 0; mode <= 1; ++mode) {
        std::cout << "Testing " << (mode ? "Logic" : "Arithmetic") << " Operations\n";
        for (int op = 0; op <= 15; ++op) {  // Loop through all 16 ALU operations (select from 0000 to 1111)
            std::cout << "  Operation select = " << op << "\n";
            for (int i = 0; i < num_tests; ++i) {
                // Random inputs
                uint16_t in_a = std::rand() & 0xFFFF;  // 16-bit random input for in_a
                uint16_t in_b = std::rand() & 0xFFFF;  // 16-bit random input for in_b
                uint8_t carry_in = std::rand() & 0x1;  // 1-bit random carry_in
                top->in_a = in_a;
                top->in_b = in_b;
                top->carry_in = carry_in;
                top->select = op;
                top->mode = mode;

                // Evaluate the ALU
                top->eval();

                // Compute expected outputs
                uint16_t expected_alu_out = 0;
                uint8_t expected_carry_out = 0;
                uint8_t expected_compare = (in_a == in_b) ? 1 : 0;

                if (mode == 0) { // Arithmetic operations
                    switch (op) {
                        case 0: expected_alu_out = in_a; break;
                        case 1: expected_alu_out = in_a | in_b; break;
                        case 2: expected_alu_out = in_a | ~in_b; break;
                        case 3: expected_alu_out = -1; break;
                        case 4: expected_alu_out = in_a | (in_a & ~in_b); break;
                        case 5: expected_alu_out = (in_a | in_b) + (in_a & ~in_b); break;
                        case 6: expected_alu_out = in_a - in_b - 1; break;
                        case 7: expected_alu_out = (in_a & ~in_b) - 1; break;
                        case 8: expected_alu_out = in_a + (in_a & in_b); break;
                        case 9: expected_alu_out = in_a + in_b; break;
                        case 10: expected_alu_out = (in_a | ~in_b) + (in_a & in_b); break;
                        case 11: expected_alu_out = (in_a & in_b) - 1; break;
                        case 12: expected_alu_out = in_a + in_a; break;
                        case 13: expected_alu_out = (in_a | in_b) + in_a; break;
                        case 14: expected_alu_out = (in_a | ~in_b) + in_a; break;
                        case 15: expected_alu_out = in_a - 1; break;
                    }
                    expected_carry_out = (expected_alu_out > 0xFFFF) ? 1 : 0; // Simulate carry out
                } else { // Logic operations
                    switch (op) {
                        case 0: expected_alu_out = ~in_a; break;
                        case 1: expected_alu_out = ~(in_a | in_b); break;
                        case 2: expected_alu_out = (~in_a) & in_b; break;
                        case 3: expected_alu_out = 0; break;
                        case 4: expected_alu_out = ~(in_a & in_b); break;
                        case 5: expected_alu_out = ~in_b; break;
                        case 6: expected_alu_out = in_a ^ in_b; break;
                        case 7: expected_alu_out = in_a & ~in_b; break;
                        case 8: expected_alu_out = (~in_a) | in_b; break;
                        case 9: expected_alu_out = ~(in_a ^ in_b); break;
                        case 10: expected_alu_out = in_b; break;
                        case 11: expected_alu_out = in_a & in_b; break;
                        case 12: expected_alu_out = 1; break;
                        case 13: expected_alu_out = in_a | ~in_b; break;
                        case 14: expected_alu_out = in_a | in_b; break;
                        case 15: expected_alu_out = in_a; break;
                    }
                }

                // Verify outputs
                if ((top->alu_out != expected_alu_out) || (top->carry_out != expected_carry_out) || (top->compare != expected_compare)) {
                    std::cerr << "ERROR: Mismatch on test " << i + 1
                              << " for operation " << op << " in mode " << mode << "\n"
                              << "Inputs: in_a = " << std::hex << in_a
                              << ", in_b = " << std::hex << in_b
                              << ", carry_in = " << (int)carry_in << "\n"
                              << "Expected: alu_out = " << std::hex << expected_alu_out
                              << ", carry_out = " << (int)expected_carry_out
                              << ", compare = " << (int)expected_compare << "\n"
                              << "Got: alu_out = " << std::hex << top->alu_out
                              << ", carry_out = " << (int)top->carry_out
                              << ", compare = " << (int)top->compare << "\n";
                }
		else {
			std::cout << "Pass: Correct on test " << i + 1 << "\n";
		}
            }
        }
    }

    // Clean up
    top->final();
    delete top;
    return 0;
}

